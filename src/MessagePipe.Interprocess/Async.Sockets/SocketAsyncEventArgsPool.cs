using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Threading;

namespace MessagePipe.Interprocess.Async.Sockets;

public class SocketAsyncEventArgsPool : IDisposable
{
    private readonly ConcurrentQueue<(SocketAsyncEventArgs Saea, DateTime ReturnTime)> _pool;
    private readonly int _maxSize;
    private readonly int _minSize;
    private readonly TimeSpan _maxIdleTime;
    private int _currentCount;
    private readonly Timer _contractionTimer;

    public SocketAsyncEventArgsPool(int initialCapacity, int maxSize, int minSize, TimeSpan maxIdleTime, TimeSpan contractionInterval)
    {
        _pool         = new ConcurrentQueue<(SocketAsyncEventArgs, DateTime)>();
        _maxSize      = maxSize;
        _minSize      = minSize;
        _maxIdleTime  = maxIdleTime;
        _currentCount = initialCapacity;

        for (int i = 0; i < initialCapacity; i++)
        {
            _pool.Enqueue((CreateNewSaea(), DateTime.UtcNow));
        }

        _contractionTimer = new Timer(ContractPool, null, contractionInterval, contractionInterval);
    }

    private SocketAsyncEventArgs CreateNewSaea()
    {
        return new SocketAsyncEventArgs();
    }

    public SocketAsyncEventArgs Rent()
    {
        if (_pool.TryDequeue(out var item))
        {
            return item.Saea;
        }

        if (Interlocked.Increment(ref _currentCount) <= _maxSize)
        {
            return CreateNewSaea();
        }
        Interlocked.Decrement(ref _currentCount);
        return null;
    }

    /// <summary>
    /// Returns the specified item.
    /// </summary>
    /// <param name="item">The <see cref="SocketAsyncEventArgs"/> instance containing the event data.</param>
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for Return
    public void Return(SocketAsyncEventArgs item)
    {
        if (_currentCount <= _maxSize)
        {
            _pool.Enqueue((item, DateTime.UtcNow));
        }
        else
        {
            DisposeSaea(item);
            Interlocked.Decrement(ref _currentCount);
        }
    }

    /// <summary>
    /// Contracts the pool.
    /// </summary>
    /// <param name="state">The state.</param>
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for ContractPool
    private void ContractPool(object state)
    {
        while (_pool.TryPeek(out var item) && DateTime.UtcNow - item.ReturnTime > _maxIdleTime)
        {
            if (_pool.TryDequeue(out item) && Interlocked.Decrement(ref _currentCount) >= _minSize)
            {
                DisposeSaea(item.Saea);
            }
            else
            {
                Interlocked.Increment(ref _currentCount);
                break;
            }
        }
    }

    /// <summary>
    /// Disposes the saea.
    /// </summary>
    /// <param name="saea">The <see cref="SocketAsyncEventArgs"/> instance containing the event data.</param>
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for DisposeSaea
    private void DisposeSaea(SocketAsyncEventArgs saea)
    {
        if (saea != null)
        {
            try
            {
                saea.Dispose();
            }
            catch (ObjectDisposedException)
            {
                // Already disposed, no action needed
            }
        }
    }


    /// <summary>
    /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
    /// </summary>
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for Dispose
    public void Dispose()
    {
        _contractionTimer.Dispose();
        while (_pool.TryDequeue(out var item))
        {
            DisposeSaea(item.Saea);
        }
    }
}